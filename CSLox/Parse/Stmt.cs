// This file is auto-generated by GenerateAST. Do not edit it manually.
using CSLox.Scan;
namespace CSLox.Parse;
abstract class Stmt
{
    public interface IVisitor<out T>
    {
        T VisitBlock(Block stmt);
        T VisitClass(Class stmt);
        T VisitExpression(Expression stmt);
        T VisitFunction(Function stmt);
        T VisitIf(If stmt);
        T VisitPrint(Print stmt);
        T VisitReturn(Return stmt);
        T VisitVar(Var stmt);
        T VisitWhile(While stmt);
    }
    public abstract T Accept<T>(IVisitor<T> visitor);
}

class Block : Stmt
{
    public List<Stmt> statements;

    public Block(List<Stmt> statements)
    {
        this.statements = statements;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitBlock(this);
    }
}
class Class : Stmt
{
    public Token name;
    public Variable superclass;
    public List<Function> methods;

    public Class(Token name, Variable superclass, List<Function> methods)
    {
        this.name = name;
        this.superclass = superclass;
        this.methods = methods;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitClass(this);
    }
}
class Expression : Stmt
{
    public Expr expression;

    public Expression(Expr expression)
    {
        this.expression = expression;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitExpression(this);
    }
}
class Function : Stmt
{
    public Token name;
    public List<Token> parameters;
    public List<Stmt> body;

    public Function(Token name, List<Token> parameters, List<Stmt> body)
    {
        this.name = name;
        this.parameters = parameters;
        this.body = body;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitFunction(this);
    }
}
class If : Stmt
{
    public Expr condition;
    public Stmt thenBranch;
    public Stmt elseBranch;

    public If(Expr condition, Stmt thenBranch, Stmt elseBranch)
    {
        this.condition = condition;
        this.thenBranch = thenBranch;
        this.elseBranch = elseBranch;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitIf(this);
    }
}
class Print : Stmt
{
    public Expr expression;

    public Print(Expr expression)
    {
        this.expression = expression;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitPrint(this);
    }
}
class Return : Stmt
{
    public Token keyword;
    public Expr value;

    public Return(Token keyword, Expr value)
    {
        this.keyword = keyword;
        this.value = value;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitReturn(this);
    }
}
class Var : Stmt
{
    public Token name;
    public Expr initializer;

    public Var(Token name, Expr initializer)
    {
        this.name = name;
        this.initializer = initializer;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitVar(this);
    }
}
class While : Stmt
{
    public Expr condition;
    public Stmt body;

    public While(Expr condition, Stmt body)
    {
        this.condition = condition;
        this.body = body;
    }
    public override T Accept<T>(IVisitor<T> visitor)
    {
        return visitor.VisitWhile(this);
    }
}
